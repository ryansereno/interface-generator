using System;
using System.IO;
using System.Text;
using System.Linq;
using System.Collections.Generic;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace CSharpToTypeScriptGenerator
{
    class Program
    {
        static void Main(string[] args)
        {
            try
            {
                Console.Write("Enter the path to the API project Applications/ directory: ");
                string rootPath = Console.ReadLine().Trim();

                if (!Directory.Exists(rootPath))
                {
                    throw new DirectoryNotFoundException("The specified directory does not exist.");
                }

                string outputDir = Path.Combine(Directory.GetCurrentDirectory(), "Interfaces");
                if (Directory.Exists(outputDir))
                {
                    Directory.Delete(outputDir, recursive: true);
                }
                Directory.CreateDirectory(outputDir);

                var generator = new TypeScriptGenerator(rootPath, outputDir);
                generator.GenerateTypeScriptInterfaces();
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error: {ex.Message}");
                Console.WriteLine(ex.StackTrace);
            }
        }
    }

    class TypeScriptGenerator
    {
        private readonly string _rootPath;
        private readonly string _outputDir;
        private Dictionary<string, HashSet<string>> _typeImports;
        private Dictionary<string, string> _typeToGroupMapping;

        public TypeScriptGenerator(string rootPath, string outputDir)
        {
            _rootPath = rootPath;
            _outputDir = outputDir;
            _typeImports = new Dictionary<string, HashSet<string>>();
            _typeToGroupMapping = new Dictionary<string, string>();
        }

        public void GenerateTypeScriptInterfaces()
        {
            var contractGroups = GetContractGroups();
            BuildTypeToGroupMapping(contractGroups);

            foreach (var group in contractGroups)
            {
                string tsFileName = Path.Combine(_outputDir, $"{ToCamelCase(group.Key)}Types.ts");
                var tsContent = new StringBuilder();
                tsContent.AppendLine("// -----------------------------------------------------------------------");
                tsContent.AppendLine("// <auto-generated>");
                tsContent.AppendLine("//     This code was generated by a tool.");
                tsContent.AppendLine("//     Changes to this file may cause incorrect behavior and will be lost");
                tsContent.AppendLine("//     if the code is regenerated.");
                tsContent.AppendLine("// </auto-generated>");
                tsContent.AppendLine("// -----------------------------------------------------------------------");
                tsContent.AppendLine();
                _typeImports[group.Key] = new HashSet<string>();

                foreach (var csFile in group.Value)
                {
                    string csCode = File.ReadAllText(csFile);
                    string tsInterface = ConvertCSharpToTypeScriptInterface(csCode, group.Key);
                    tsContent.AppendLine(tsInterface);
                }

                // Add import statements at the beginning of the file
                var importStatements = GenerateImportStatements(group.Key);
                tsContent.Insert(0, importStatements);

                File.WriteAllText(tsFileName, tsContent.ToString());
                Console.WriteLine($"Generated: {tsFileName}");
            }

        }

        private Dictionary<string, List<string>> GetContractGroups()
        {
            var contractGroups = new Dictionary<string, List<string>>();

            foreach (var contractsDir in Directory.GetDirectories(_rootPath, "Contracts", SearchOption.AllDirectories))
            {
                string groupName = Path.GetFileName(Path.GetDirectoryName(contractsDir));
                contractGroups[groupName] = Directory.GetFiles(contractsDir, "*.cs").ToList();
            }

            return contractGroups;
        }

        private void BuildTypeToGroupMapping(Dictionary<string, List<string>> contractGroups)
        {
            foreach (var group in contractGroups)
            {
                foreach (var csFile in group.Value)
                {
                    var tree = CSharpSyntaxTree.ParseText(File.ReadAllText(csFile));
                    var root = tree.GetCompilationUnitRoot();
                    var classDeclarations = root.DescendantNodes().OfType<ClassDeclarationSyntax>();

                    foreach (var classDeclaration in classDeclarations)
                    {
                        _typeToGroupMapping[classDeclaration.Identifier.Text] = group.Key;
                    }
                }
            }
        }

        private string ConvertCSharpToTypeScriptInterface(string csCode, string currentGroup)
        {
            var tree = CSharpSyntaxTree.ParseText(csCode);
            var root = tree.GetCompilationUnitRoot();
            var classDeclarations = root.DescendantNodes().OfType<ClassDeclarationSyntax>();

            var sb = new StringBuilder();

            foreach (var classDeclaration in classDeclarations)
            {
                sb.AppendLine($"export interface I{classDeclaration.Identifier.Text} {{");

                foreach (var property in classDeclaration.DescendantNodes().OfType<PropertyDeclarationSyntax>())
                {
                    string tsType = MapCSharpTypeToTypeScript(property.Type, currentGroup);
                    string propertyName = ToCamelCase(property.Identifier.Text);
                    bool isNullable = IsNullableType(property.Type);

                    sb.AppendLine($"  {propertyName}: {tsType}{(isNullable ? " | null" : "")};");
                }

                sb.AppendLine("}");
                sb.AppendLine();
            }

            return sb.ToString();
        }

        private string MapCSharpTypeToTypeScript(TypeSyntax typeSyntax, string currentGroup)
        {
            if (typeSyntax is NullableTypeSyntax nullableType)
            {
                return MapCSharpTypeToTypeScript(nullableType.ElementType, currentGroup);
            }

            if (typeSyntax is GenericNameSyntax genericType)
            {
                string baseType = genericType.Identifier.Text;
                string typeArgument = MapCSharpTypeToTypeScript(genericType.TypeArgumentList.Arguments[0], currentGroup);

                return baseType switch
                {
                    "List" or "IEnumerable" or "ICollection" => $"Array<{typeArgument}>",
                    "Dictionary" => "{ [key: string]: any }",
                    _ => $"{baseType}<{typeArgument}>"
                };
            }

            string csharpType = typeSyntax.ToString();

            return csharpType switch
            {
                "int" or "long" or "float" or "double" or "decimal" => "number",
                "bool" => "boolean",
                "string" => "string",
                "DateTime" => "Date",
                "DateOnly" => "Date",
                "Guid" => "string",
                _ => HandleComplexType(csharpType, currentGroup)
            };
        }

        private string HandleComplexType(string typeName, string currentGroup)
        {
            string interfaceName = $"I{typeName}";

            if (_typeToGroupMapping.TryGetValue(typeName, out string typeGroup) && typeGroup != currentGroup)
            {
                if (!_typeImports.ContainsKey(currentGroup))
                {
                    _typeImports[currentGroup] = new HashSet<string>();
                }
                _typeImports[currentGroup].Add($"{typeGroup}:{typeName}");
            }

            return interfaceName;
        }

        private string GenerateImportStatements(string currentGroup)
        {
            var importGroups = _typeImports[currentGroup]
                .GroupBy(t => t.Split(':')[0])
                .ToDictionary(g => g.Key, g => g.Select(t => t.Split(':')[1]).ToList());

            var sb = new StringBuilder();
            foreach (var import in importGroups)
            {
                string importGroupName = ToCamelCase(import.Key);
                string importTypes = string.Join(", ", import.Value.Select(t => $"I{t}"));
                sb.AppendLine($"import {{ {importTypes} }} from './{importGroupName}Types';");
            }
            if (sb.Length > 0)
            {
                sb.AppendLine();
            }
            return sb.ToString();
        }

        private bool IsNullableType(TypeSyntax typeSyntax)
        {
            return typeSyntax is NullableTypeSyntax;
        }

        private string ToCamelCase(string s)
        {
            if (string.IsNullOrEmpty(s) || !char.IsUpper(s[0]))
                return s;

            char[] chars = s.ToCharArray();
            chars[0] = char.ToLower(chars[0]);
            return new string(chars);
        }
    }
}
